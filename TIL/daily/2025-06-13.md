
## 📘 추상 클래스 vs 인터페이스 (Dart 기준)


---


### 🔷 추상 클래스 (Abstract Class)

- **정의**: 상속의 재료로 사용되는 클래스, 일부 메서드가 미정의된 클래스
- **용도**: 미래 개발자가 상속받아 구현할 수 있도록 틀(template) 제공
- **특징**:
    - `abstract` 키워드 사용
    - **일부 메서드만 추상 메서드여도 됨**
    - **인스턴스화 불가능**
    - 상속을 통해 구체 클래스가 반드시 추상 메서드를 구현해야 함

```dart

abstract class Animal {
  void speak(); // 추상 메서드
  void breathe() => print("숨 쉰다"); // 일반 메서드도 가능
}
```


---


### 🔷 인터페이스 (Interface)

- **정의**: 모든 메서드가 추상 메서드인 특수한 형태의 추상 클래스
- **Dart에서 interface는 특별한 키워드 없이도 class로 표현**
- Dart 3.0부터 `interface` 키워드가 공식 도입됨
- **특징**:
    1. 모든 메서드는 **추상 메서드**
    2. **필드(멤버 변수)** 를 가질 수 없음
    3. **다중 구현(implements A, B, C)** 가능 → 다중 상속 효과
    4. 구현(implement)한 클래스는 인터페이스의 모든 메서드를 반드시 구현해야 함

```dart

interface class Flyable {
  void fly();
}

class Bird implements Flyable {
  @override
  void fly() => print("새가 난다");
}

```


---


### ✅ 인터페이스의 효과

1. **공통 메서드 구현 보장**
    - 동일 인터페이스를 구현한 클래스들은 **공통된 메서드**를 구현함이 보장됨
2. **유형 체크 및 다형성 제공**
    - 특정 클래스가 인터페이스를 구현하고 있다면, **그 인터페이스의 역할을 수행할 수 있음이 보장**됨

---


### 👨‍💻 상속 재료를 만드는 개발자의 역할

- **미래의 개발자**가 안심하고 사용할 수 있도록 **안정적이고 예측 가능한 부모 클래스 작성**
- **인스턴스화를 방지**하고, **미구현 메서드 강제** 등을 통해 오용 방지
- 코드의 재사용성과 확장성을 고려한 설계 필요

---


### 🆚 정리: 추상 클래스 vs 인터페이스


| 항목    | 추상 클래스            | 인터페이스                         |
| ----- | ----------------- | ----------------------------- |
| 키워드   | `abstract class`  | `interface class` (Dart 3.0+) |
| 메서드   | 일부는 구현 가능         | 모두 추상 메서드만 가능                 |
| 필드 선언 | 가능                | 불가능                           |
| 인스턴스화 | 불가능               | 불가능                           |
| 상속 구조 | 단일 상속             | 다중 구현(implements A, B, C) 가능  |
| 사용 목적 | 기본 기능 + 확장 포인트 제공 | 기능 명세 제공, 역할 중심 설계            |

