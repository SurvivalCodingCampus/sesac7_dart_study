# 인스턴스의 기본 조작

## 과제 피드백 내용
#### 1. 인터페이스가 많아지는 것에 대해 부정적인 시각을 가지지 말 것. 오히려 인터페이스를 이용할 경우 확장성에 많은 도움을 준다. (객체지향을 활용하는 방법, 추상 클래스는 사용 지양)
- Bionic과 Mechanic 분기는 추상 클래스로 굳이 만들지 않아도 될 분기인데 중요하지 않은 부분에 너무 욕심을 부렸다.
- 당장 추가되어야 할 속성이 없다면 굳이 추상 클래스를 사용할 필요는 없다.

#### 2. heal-healed, attack-attacked와 같은 부분은 굳이 나눌 필요가 없다. healed나 attacked가 사용되지 않는 경우가 존재할 가능성이 있음.

- 하나의 메소드에서 처리할 수 있도록 수정하면 좋을 것 같음.
#### 3. 각 종족에 대한 패치를 해야 될 경우 종족 분기가 없어 어려움이 있다.
- 이것도 인터페이스와 관련된 부분.

#### 4. attacker에 대한 구현이 상당 부분 잘못되었다. 
- 메딕을 제외하고서도 다른 종족에 공격을 못하는 유닛이 추가될 수도 있다고 생각하면, Bionic과 Mechanic에 받는 것은 좋지 않은 부분이다. (이것도 1번과 관련된 부분)

#### 5. 바텀업 방식이 설계하기에 더 나았을 수 있다.

## Object 클래스
모든 클래스는 Object 클래스를 암묵적으로 상속하며, Object 클래스의 기본 기능들을 사용 가능하다.   

1. toString 메소드
    - toString 같은 경우 오버라이드하여 사용자가 원하는 문자열을 리턴하는 형태로 사용 가능하다.

2. == 연산자
    - 동등성 비교 규칙을 재정의한다.
    - 참조에 대한 비교 연산(두 객체가 같은 주소를 가지고 있는지?)은 identical(Object, Object)을 통해 진행한다.
    ```dart
    identical(Object obj1, Object obj2);
    ```
    - 비교 규칙을 바꾸면 List 내부에서의 동등성 비교 로직 등도 바뀌므로 신중하게 사용할 필요가 있다.

3. hashCode 프로퍼티
    - 객체마다 갖는 고유 값. 같은 객체라면 같은 값을 갖는다.
    - 기본 타입의 경우 값이 같으면 hashCode 값도 같다.
    - 언제나 바뀌는 변동성이 있는 값이다.
    - 비교 규칙을 바꾸면 Set, Map 내부에서의 동등성 비교 로직이 바뀌므로 신중하게 사용할 필요가 있다.

## List, Set의 동등성 비교
#### List
'==' 연산자를 이용해 비교한다. 순차 탐색이며, 클래스의 경우 모든 멤버에 대해 동등성 검사를 진행해야하므로 속도가 느리다.
#### Set
hashCode를 비교한다. Map도 같은 방식이며, hashCode 값만 비교하므로 탐색 속도가 빠르다.
=> human error 방지를 위해 두 자료구조의 동등성 비교 규칙을 맞춰주는 것이 좋다.

## sort
정렬 기능을 가진 메소드.
- dart에서의 sort는 원본을 변경시킨다. (좋지 않음)

- 인자에는 정수값을 리턴하는 함수를 대입할 수 있고, (a, b) => a.compareTo(b)와 같은 형태로 작성한다. 

- sort가 가능하려면 Comparable 인터페이스를 구현 후 compareTo 메소드를 오버라이드 해야한다.

- 기본적으로는 오름차순 정렬을 진행하며, -를 붙여서 내림차순 정렬로 바꾸는 것도 가능하다.

## 원본의 상태를 바꾸는 sort는 좋지 않음
- 따라서 우리는 라이브러리를 통해 sorted 메소드를 사용할 것이다.

- sorted는 sort와 똑같이 작동하나, 원본을 바꾸지 않고 정렬된 복사본을 반환한다.

- sorted의 경우 인자로 함수를 무조건 넣어주어야하나, Comparable을 구현한 후 compareTo를 오버라이드했다면 인자를 넣지 않아도 된다. (comepareTo의 기본 형태가 구현이 됐으므로)

## 객체 복사
- dart에서는 기본(primitive) 타입에 대해서는 복사를 허용하지만, 사용자가 생성한 클래스에 대해서는 참조하는 방식을 기본적으로 허용한다.
- 객체를 복사하기 위해서는 copyWith 메소드를 만들어 활용하는 방법이 있다.

## 얕은 복사 vs 깊은 복사
- 클래스의 필드에 사용자가 정의한 클래스 타입의 객체 혹은 DateTime과 같은 객체가 존재하면, 그것들을 그냥 복사했을 때 인스턴스는 2개인데 복사된 객체가 기존 객체의 필드 속성을 공유하는 문제가 발생할 수 있다.
- 따라서 그런 일이 발생하지 않게 하기 위해서는 복사하는 과정에서 새로운 인스턴스를 필드로 생성(new)하는 방식으로 복사를 진행하는 것이 합당하다.