# TIL

## 2025-06-19 - 인스턴스 기본조작

### 과제리뷰

인터페이스가 많다고 해서 나쁜게 아니다. 확장성에서 굉장히 유리하기 떄문에. 다양한 형태를 만들기도 좋고 확장성도 좋고.
인터페이스가 많아진다고해서 우려하지 않아도된다.

추상클래스 보다는 인터페이스를 기본으로 가져가는게 확장에 유리하다.
속성이 존재 한다면, 추상클래스를 고민하고, 인터페이스에 getter/setter 넣을 수 있기 때문에,
인터페이스를 많이 잘 쓰는게 객체지향을 잘 쓰는거다.
추상 클래스는 확장성이 좋지 않기 때문에 인터페이스를 적극적으로 쓰는게 좋다.

Bottom-Up 방식으로 개체부터 설계하고 특징뽑아내서 추상이든 인터페이스든 만들고,
인터페이스 많은거 괜찮다.
너무 많다고 생각하면 인터페이스를 또 묶어서 해라. 문제 없다. 잘게 많이 쪼개져 있다고 문제 없다. 오히려 좋다.

앞으로 플러터에서 제공하는 코드 방식이라던지, 읽고 흐름을 이해하기 위해서 이런 객체지향을 배운다.

### Object 클래스

모든 클래스는 Object 클래스의 메소드와 프로퍼티를 가지고 있다.   
Object 타입의 변수에는 모든 인스턴스를 대입할 수 있다.

Object 클래스의 대표적인 메소드 및 프로퍼티로는

- toString() : 문자열 표현을 얻음.
- operator == : 비교.
- hashcode : 해시값을 얻음.

이 대표적으로 존재한다.

이런 메소드와 프로퍼티를 사용자의 입맞에 맞게끔 재정의하여 사용할 수 있다.

==(equals)를 재정의 하여, ==으로 비교시 나만의 동등성 규칙을 세울 수 있다.
List에서 동등성 비교시 사용된다.

hashcode를 재정의하면 Set,Map 내부에서 동등성 규칙으로 사용된다.

Set,Map 계열은 요소를 검색할 때, hashCode를 사용하여 빠르다. List는 순차검색이라 느리다.
=> 모든 객체는 해시 값을 가지고, 동일한 객체는 항상 같은 해시 값을 가진다.

List에서는
List.sort()를 통해서 요소 정렬을 하는데, Dart의 sort()는 원본을 재정렬하여 반환한다.

그래서 collection 패키지의 sorted()를 사용하자.    
원본은 그대로 두고, 복사본을 반환하기 위해서.

미리 정렬 규칙을 정하기 위한 Comparable Interface는 아래와 같음.

```dart
class X implements Comparable<X> {
  @override
  int compareTo(X other) {
    // TODO: implement compareTo
    return X.name.compareTo(other.name);
  }
}
```

과 같이 미리 정렬 규칙을 클래스에서 compareTo()를 재정의 하여놓음.

즉석에서 정렬 규칙을 정하기 위한 Comparator 함수는 아래와 같음.

```dart
void main() {
  list.sorted((a, b) => a.compareTo(b));
}

```

와 같이 sorted()함수 내에서 Comparator함수를 정의.

Comparator 함수는 두 개의 같은 타입의 객체를 받아 비교한 뒤, 정수 값을 반환하는 함수이다.
a가 b보다 작으면 음수
a와 b가 같으면 0
a가 b보다 크면 양수

identical()  메소드는 객체의 주소값을 비교하여 동등값 검사를 하는 방법이다.

Dart에서의 객체복사는 copyWith()를 통해 가능하다.

정리를 하자면
객체의 동등성 비교를 위해 ==(equals) 메소드와 hashCode를 재정의해준다.
객체의 내용을 알기 쉽게 보여주기 위해 toString() 메소드를 재정의해준다.
복사를 지원하기 위해 copyWith()를 작성한다. 


