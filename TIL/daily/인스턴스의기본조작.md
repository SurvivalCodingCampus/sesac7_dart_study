## 인스턴스의 기본조작 <동등성 비교 == hashcode, 매서드 재정의, 복사 copyWith>

toString() 자동완성으로 만들어도된다.
오버라이딩하여 만든다.

# == 동등성비교 재정의
 - 나만의 동등성 규칙을 만들수있다.
 - 재정의가 필요할때가 있다.
 - identcal(object,object) <- 참조주소비교
 - 참조가 아닌 같은놈은 뺀다 리스트안에서

# hashcode 
 - 인트값 - 각객체마다 hash코드 로 생각해도 무방하다 , 같은 값이 없기에
 - hashcode에서 재정이하면 동등성비교 set,map에서
 - set에서는 hashcode가같은면 같은걸로
 - hashcode 기반이 연산에 빠르다

```dart
// hashCode를 재정의하면 Set, Map내부에서의 동등성 규칙으로 사용 됨
@override
int get hashCode => name.hashCode ^ age.hashCode;
```

# set map 동작의 원리
Set, Map 계열은 요소를 검색할 때 hashCode 를 사용하여 빠르다. List는 순차검색이라 느림
모든 객체는 해시값을 가진다
동일한 객체는 항상 같은 해시값을 가진다.

# sort()
 - 원본을 바꾸어 버린다. 절대 쓰지말자 dart만 원본을 바꾸어버린다.
 - https://pub.dev/packages/collection  sorted((a,b) => a.compareTo(b))
 - 위의 패키지를 사용하자

# ..
 - 연산자 void 를 참조로 리턴해주는거

# comparTo()
 - 재정의 안한다. 귀찮으니깐

# 객체복사
 - copyWith 메서드 구현

# 얕은복사
 - 객체의 복사본을 생성할 때 원본 객체와 같은 메모리 주소를 공유하는 경우
 - 즉, 객체 내의 참조형 필드는 복사되지 않고 참조만 복사
 - 하나의 객체를 변경하면 다른 객체도 변경되는 문제가 발생

# 깊은복사
 - 객체의 복사본을 생성할 때 원본 객체와 별개의 메모리 주소를 가지도록 모든 필드와 하위 객체를 재귀적으로 복사
 - 원본 객체와 복사본 객체가 완전히 독립적인 개체
 - 하나의 객체를 변경해도 다른 객체에는 영향을 주지 않는다.

# hashCode값
 - hashCode는 객체의 메모리 주소가 아닌, 객체의 상태(State), 즉 필드 값들을 기반으로 계산

# identical(a,b)
 - 동일 주소인가 확인
 - 함수는 두 객체가 실제로 같은 객체인지, 즉 메모리 상에서 동일한 객체를 가리키는지를 확인하는 데 사용
 - identical() 또는 기본 ==: 메모리 상에서 같은 객체인가? (동일성)
 - 재정의된 ==: 내용이 같은 객체인가? (내용 동등성)

# identical과 ==
 - identical() 함수와 == 연산자는 의미가 다름 
 - identical()은 두 객체가 메모리 상에서 정확히 같은 객체인지를 확인 (같은 인스턴스인를 가르키는지)
 - == 연산자는 객체의 동등성(equality)을 비교 즉, == 연산자는 객체의 값이 같은지 비교하도록 재정의
