# Test 이론, Model 클래스와 Repository

## 과제 피드백
#### 1. 비동기 방식으로 코드를 작성하려고 했다면 메소드(함수) 또한 비동기 메소드(함수)를 사용해주는 것이 낫다.
readAsLineSync의 경우 동기 방식으로 작동하며, Flutter로 갔을 때 스레드를 점유해버려(dart는 단일 스레드로 작동하기 때문에) 다른 일을 할 수가 없어진다.
#### 2. List 타입 캐스팅에서 dynamic 대신 String을 사용하는 것이 나을 것 같다.
dynamic을 사용하는 경우는 Map으로 충분하다.
#### 3. csv의 첫 라인(인덱스 라인)을 날리는 로직을 넣는 것이 좋을 것 같다.
skip()을 사용하면 첫 줄을 날릴 수 있다고 한다.
#### 4. 객체를 다양한 용도로 사용해야할 수 있으므로, Impl 타입 변수를 만드는 것보다는 인터페이스 타입으로 선언하는 것이 다형성 활용 측면에서 더 좋은 방법이다.
#### 5. 인터페이스를 구현한 클래스(Impl과 같은)에 클래스 독자적인 요소들(ex: getter/setter 등)을 만들지 않고, 인터페이스 내부에 있는 것들만(오버라이드한 것들만) 접근하는 것이 일반적이다.
- 인터페이스의 존재만 알고 있을 경우 그것을 구현한 클래스 내부의 요소를 알지 못할 경우가 있다.
- 무언가 값을 세팅해야 한다면 생성자로 처리하는 것도 좋은 방법이다.
#### 6. join을 사용하면 여러 개의 데이터를 리스트로 묶을 수 있다.

## Test
클래스 작성을 완료했다고 개발이 끝난 것이 아니다.

오류 확인 및 품질 향상을 위해 테스트가 꼭 필요하다.

우리가 지금까지 한 것은 단위 테스트(하나의 기능에 대한 테스트)이며, 이후 Flutter로 가게 되면 UI 측면이 추가되기 때문에 통합 테스트 또한 진행할 예정이라고 한다.

## Test가 꼭 필요한 경우
#### 1. DB 등 데이터 혹은 데이터의 구조가 변경되었을 경우
#### 2. 네트워크 연결 여부에 따른 반응을 확인할 때
#### 3. 데이터를 예측한 값으로 정확히 처리하고 있는지 검증할 때

## Test 팁
#### 1. 인터페이스를 활용하여 객체 간 의존을 줄이는 방향으로 테스트를 설계해야한다.

#### 2. 테스트 진행 시 Mock 객체를 활용하고, 문제가 없다면 통신 환경에 맞게 Mock 객체의 구조를 수정하여 실사용 객체를 만드는 것이 편리하다.

    1. Fast (빠르고)
    2. Reliable (믿을 수 있고)
    3. Independent (독립적인)
    4. Ease of Maintenance (유지 관리가 쉽고)
    5. Nearly compacted code (거의 압축적인 코드)
    6. Dependencies should be less (의존성이 적어야 한다)


## Model 클래스
데이터의 구조를 정의한다.

불변 객체로 유지하는 것이 좋다.


## constant 생성자
해당 클래스가 불변 객체일 때(모든 요소가 final일 경우) 생성자에 const를 붙여 사용할 수 있다.

const 생성자로 생성된 객체의 경우 값이 같다면 같은 객체로 본다.

## Repository
- 데이터에 직접적으로 접근하지 않도록 제한하고(추상화), DataSource에 대한 관리 및 데이터 전달 기능을 맡는다.
(데이터에 대한 직접적 접근은 DataSource가 처리한다.)

- 도메인과 관련된 기능을 담는다.
## 참고 사항
- <code>explicitToJson: true</code> 옵션의 경우, 클래스가 중첩되어있을 때 내부 클래스의 toJson을 자동으로 호출하도록 해주는 옵션이므로 꼭 작성할 것.	